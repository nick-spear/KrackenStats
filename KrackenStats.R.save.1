# ===========================================================#
#
#  File:        KrackenStats.R
#  Author:      Nickolas Spear
#  Updated:     July 28, 2017
#
# = OUTLINE OF FUNCTIONS
#
#   - parseInput(string)
#        Evaluates input string and determines function 
#        calls depending on input.
#
#   - getTable()
#        Pulls database's password table as data frame.
#
#   - userStats(string, data.frame)
#        Collects and returns data regarding input 
#        password string.
#
#   - top(integer, data.frame)
#        Gets top (integer) fastest crack times, most
#        popular passwords in wild, and most popular 
#        seen passwords
#
#   - charFreq(table)
#        Gets frequency of each whitelisted character in 
#        the set of all unique input passwords
#
#   - charRelFreq(table)
#        Gets the relative frequency of each whitelisted 
#        character in the set of all unique input passwords
#
#   - charFreqSummary(data.frame)
#        Gets both the frequency and relative frequency of 
#        each whitelisted character in the set of all 
#        unique input passwords
#
#   - propotions(data.frame)
#        Gets average poportions of lowercase letters, 
#        uppercase letters, numbers, and special characters 
#        in the data.frame's population of passwords.
#
#   - passPropotions(string)
#        Gets the propotion of lowercase letters,
#        uppercase letters, numbers, and special characters 
#        of the input string.
#
#
# = ASSUMES THE FOLLOWING DATABASE COLUMN TITLES:
#     plaintext ............... Parsed Password
#     cpu_brute_time .......... Brute force crack time
#     seen_count .............. Number of times seen by front-end
#     from_public ............. From public table
#     rank_wild ............... Popularity rank in wild
#
# ===========================================================#


library(rjson)
library(RPostgreSQL)

server <- function() {
    
    errLog <- file("KrackenErrorLog.txt", open = "wt")
    sink(file = errLog, append = TRUE, type = "message")

    outLog <- file("KrackenOutputLog.txt", open = "wt")
    sink(file = outLog, append = TRUE, type = "output")

    hostIn <- "10.0.3.54"
    portIn <- 8888
    blockingIn <- TRUE
    serverIn <- TRUE
    openIn <- "r+"

    writeLines(paste(Sys.time(), " : Began Kracken sesssion", sep=""))

    while(TRUE) {
#        connection <- socketConnection(host=hostIn, port=portIn, blocking=blockingIn, server=serverIn, open=openIn)
        make.socket(host = hostIn, port = portIn, fail = TRUE, server = TRUE)
        data <- read.socket(connection)
        writeLines(paste(paste(Sys.time(), " : Received ", sep=""), "Stuff" , sep=""))
        if(!identical(data, character(0))) {
          response <- "Hi Rob" 
#parseInput(data)
          writeLines(paste(Sys.time(), paste(" : Responded ", response, sep=""), sep=""))
          writ(response, connection)
        } else {
          writeLines(paste(Sys.time(), " : Unable to respond", sep=""))
        }
        close(connection)
    }
}


parseInput <- function(input) {
	
    # Takes in user input, greedily splits on whitespace, and parses accordingly.
    args <- strsplit(input, "\\s+")[[1]]

    out <- "NULL"
    if (length(args) >= 1 ) {
        if (args[1] == "getuserstats") {
            table <- getTable()
            out <- toJSON(userStats(args[2], table[table$seen_count > 0,]))
        } else if (args[1] == "gettop") {
            table <- getTable()
            num <- strtoi(args[2], 10)
            out <- toJSON(top(num, table[table$seen_count > 0,], table[table$rank_wild > 0,]))
        }
    }

    result <- "Hi Rob"
    
}

getTable <- function() {
    
    # Function to get current password database
    
    # Sets variables for database connection
    database_name <- "imt-admin"
    user_name <- "imt-admin"
    pass <- "1q2w3e4r"
    host_val <- "10.0.3.7"
    port_val <- "5432"

    writeLines(paste(Sys.time(), ": Establishing database connection..."))
    datab_con <- dbConnect(dbDriver("PostgreSQL"), user=user_name, password=pass, dbname=database_name, host=host_val, port=port_val)
    writeLines(paste(Sys.time(), ": Connection established. Sending query..."))
    result <- dbGetQuery(datab_con, "SELECT id FROM rainbow WHERE id = 382650")    
#result <- dbGetQuery(datab_con, "SELECT id,plaintext,cpu_brute_time,seen_count,rank_wild FROM rainbow WHERE rank_wild > 0 OR seen_count > 0")
    writeLines(paste(Sys.time(), ": Response to query received."))
    output <- result

#passwords <- data.frame(
#    plaintext = c("N3@_Fj>^s)F`+N", "&H.%q00<^M5wLD", ";KJj!zbCwR&qm2", "*?4[6:uMt(vtDb", "{gyCZS<[56>-(F", "NqTec_u<c]=LQ&", "<A/2P[Al]ctIl7", "?.-pvntrkx;g8m", "*>=gk%.Mgn]0,y", "V|!?`*.!8Y$o`3",
#                "(R.sS@,o8E55L", "Z+gujQE@!BCj8", "Jrtr'@'_=J'_h", ")|J*qvti~TJYn", "g9!|~5UwOevp#", "/@fIE[,Af=Dke", "f-(o&2GrHa|Km", "t.5Dn6XM5*}|{", "Rzml<^svi$F8b", "#.=xD;,T16rjp",
#                "_rJ4!0gxg=uT", "^YrF#;:Xc?WM", ">SGeo''TG75k", "s;klD%Y4G{L*", "q^Jhk2/cq$A(", "WoR~nn`M295V", "zA^+Q!t#0*PY", "]kgv6+;cl`}`", "tf=f!-T5]hq'", "jm<5i&sS5'E#",
#                "qIFR2#G!~kx", "0K`8vORIe2[", "#?ylVzv<}nt", "Wt7iac$ICRY", "D0V1]5OjRc6", "6%s@CN7}B5x", "x059EMM?%53", "Ca)t7F;g+>Q", "H4r},:yoh@;", "2IGPl{[#xtb",
#                "gm9HI.64mi", "_I;o9^Iiwp", "<_8M`Q9<]R", "9M]RV=-b)a", "[wcU6<!^ez", "!pZeJTn5oe", "jsr[+sysyb", "!*iGftFh^3", ":yk_PCYBu<", "m^Gw!;hB|9",
#                "LBU5Z^Zfw", ";[;5uO87`", "M!/R..*GM", "Z{L-aQBuQ", "D66`icE,a", "9S2/Y!|iS", "fl^Ya)xM'", "h0$!WA+cC", "#feIHiZaq", "(@',.!WBx",
#                "5OcnV[!|", "]?]]&VL?", "vytxB1lP", "q@{jA5wJ", "0KM_r-9<", "Wag@{4BO", "ynV;D1T2", "^{k]n`kw", "l411iYa4", "b>P,ni8,",
#                "I;M^<&i", "Dlf|m)8", "0jR6t}r", "P(;h1,K", "w;;L&G;", "8PD+lc@", "oA4iAr2", "3Bj}q0L", "!gEk/[e", "L|Al5Mo",
#                "0vhoca", "|stcPM", "4WGxIN", "f>he^%", "+9U/D4", "S]oL.C", "J(&Ili", "x|VPKq", "G_$1ss", "=hgx'y",
#                "EpD[l", "wlr;q", "E(R7e", "@AN8R", ":ax7O", "bl<Yy", "7Y<F-", "4p+pQ", "UW3`>", "yHe0="),
#    cpu_brute_time = c(2071, 2018, 1200, 1980, 1878, 2242, 1956, 1798, 1875, 1557, 
#                               1003, 1519, 1342, 1101, 1112, 1024, 1069, 844, 975, 1218, 
#                               1013, 1168, 721, 798, 842, 456, 796, 499, 686, 544, 
#                               726, 444, 474, 477, 484, 621, 505, 788, 605, 488, 
#                               448, 454, 609, 313, 198, 494, 295, 258, 261, 305, 
#                               239, 173, 481, 415, 151, 144, 252, 237, 241, 120, 
#                               137, 426, 177, 72, 165, 89, 120, 192, 135, 101, 
#                               128, 157, 140, 493, 239, 114, 93, 302, 281, 66, 
#                               112, 109, 131, 100, 415, 264, 37, 128, 140, 51, 
#                               24, 33, 75, 72, 220, 155, 124, 54, 133, 34),
#    seen_count = c(2, 2, 2, 0, 6, 2, 0, 8, 0, 1,
#                   3, 6, 6, 5, 3, 7, 2, 2, 4, 2,
#                   6, 2, 6, 3, 5, 7, 7, 0, 3, 6,
#                   6, 1, 5, 3, 3, 5, 2, 2, 3, 3,
#                   6, 2, 4, 1, 2, 1, 4, 2, 5, 2,
#                   5, 6, 5, 2, 2, 5, 5, 2, 2, 4,
#                   0, 2, 4, 5, 0, 7, 3, 0, 7, 5,
#                   2, 5, 2, 2, 5, 6, 2, 1, 7, 6,
#                   1, 1, 7, 5, 6, 4, 5, 6, 6, 1,
#                   1, 9, 4, 4, 8, 6, 0, 7, 7, 6),
#    from_public = c(TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, 
#                    FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, 
#                    FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, 
#                    FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#                    FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, 
#                    TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE, 
#                    TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#                    TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, 
#                    FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, 
#                    TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE),
#    rank_wild = c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     4, 0, 0, 0, 0, 0, 10, 0, 0, 0, 
#                     5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#                     9, 0, 0, 0, 0, 0, 0, 0, 0, 0)
#)
    
}

userStats <- function(string, table) {

    # Pulls in password string value and returns a JSON containing the following:
    #     cpu_brute_time: (float) ....... Exact entry in cpu_brute_time
    #     percentile: (integer) ......... Percentile result amond all unique entered passwords
    #     rank: (integer) ............... Rank of value among all unique entered passwords sent to bruteforce
    #     unique_pass_count: (integer) .. Returns number of unique passwords entered by users
    #     average: (float) .............. Average Krack time of brute-forced population


    # Pulls Kracktime associated with password string
    Krack_time_val <- table$cpu_brute_time[match(string, table$id)]

    # Pulls percentile of value
    percentile_val <- floor(ecdf(table$cpu_brute_time)(Krack_time_val) * 100)
    
    # Gets all passwords sent to brute-force cracker
    valid_Kracks <- table[table$cpu_brute_time > 0,]

    # Sums the boolean of each value greater than string's length, returns that + 1 for rank
    rank_val <- sum(table$cpu_brute_time > Krack_time_val) + 1

    # Finds number of unique passwords entered
    number_of_passes_val <- NROW(table$seen_count)

    # Pulls current average of passwords$cpu_brute_time
    average_val <- mean(valid_Kracks$cpu_brute_time, na.rm = TRUE)

    result <- list(cpu_brute_time = Krack_time_val, percentile = percentile_val, rank = rank_val, unique_pass_count = number_of_passes_val, average = average_val)
}

top <- function(numval, seen_table, wild_table) {

    # Finds the [num] fastest crack timees, [num] most popular passwords in the wild, 
    #       and [num] most popular passwords we've seen

    # Returns the sorted data in the following Javascript Object format:
    #
    # { "fastest" : [Array of object literals {"password":(string), "cpu_brute_time":(integer)} that correspond
    #               to the fastest 'num' crack times, in order of increasing time (fastest at index 0)]
    #   "wild_common" : [Array of object literals {"password":(string), "rank_wild":(integer)} that correspond
    #                    to the highest ranking popular passwords in the wild, in standard numeric order (rank 1 at index 0)]
    #   "seen_common" : [Array of object literals {"password":(string), "seen_count":(integer)} that correspond
    #                    to the most common passwords WE have seen, in order of decreasing frequency (most common at index 0)]
    # }

    worstKracksArray <- c()
    seenCommonArray <- c()
    wildCommonArray <- c()    

    num <- numval
    
    if ( nrow(seen_table) > 0 ) {
        if ( nrow(seen_table) < numval ) { num <- nrow(seen_table) }

        worstKracks <- seen_table[seen_table$cpu_brute_time > 0,]
        worstKracks <- worstKracks[order(worstKracks$cpu_brute_time, decreasing = FALSE),][1:num,]
        worstKracks <- subset(worstKracks, select = c("plaintext", "cpu_brute_time"))
        worstKracksArray <- split(worstKracks, seq(nrow(worstKracks)))
        names(worstKracksArray) = NULL
    
        seenCommon <- seen_table[order(seen_table$seen_count, decreasing = TRUE),][1:num,]
        seenCommon <- subset(seenCommon, select = c("plaintext", "seen_count"))
        seenCommonArray <- split(seenCommon, seq(nrow(seenCommon)))
        names(seenCommonArray) = NULL
    }

    if ( nrow(wild_table) > 0 ) {
        if ( nrow(wild_table) < numval ) { num <- nrow(wild_table) }

        wildCommon <- wild_table[wild_table$rank_wild > 0,]
        wildCommon <- wildCommon[order(wildCommon$rank_wild, decreasing = FALSE),][1:num,]
        wildCommon <- subset(wildCommon, select = c("plaintext", "rank_wild"))
        wildCommonArray <- split(wildCommon, seq(nrow(wildCommon)))
        names(wildCommonArray) = NULL
    }

    finalResult <- list(fastest=worstKracksArray, wild_common=wildCommonArray, seen_common=seenCommonArray)
}

charFreq <- function(table) {

    # Splits vector of password password into a character vector, then
    # Sums the occurrences for each whitelisted character and returns the sorted result

    seen_table <- table[seen_count > 0,]
    white_list <- c("!", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~")
    password_to_chars <- unlist(strsplit(as.character(seen_table$plaintext), ""))
    result <- sort(sapply(white_list, function(x) x <- sum( x == password_to_chars )), decreasing=TRUE)
}

charRelFreq <- function(table) {

    # Finds frequency identically to as in charFreq() and divides the result vector by
    # the number of characters in the split character array

    seen_table <- table[seen_count > 0,]
    white_list <- c("!", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~")
    
    password_to_chars <- unlist(strsplit(as.character(seen_table$plaintext), ""))
    result <- sort(sapply(white_list, function(x) x <- sum( x == password_to_chars )), decreasing=TRUE)
    result <- charFreq() / length(password_to_chars)
}

charFreqSummary <- function(table) {

    # Calls charFreq() and charRelFreq() to obtain character frequency data and 
    # formats to a JSON with the following members:
    #   character : Array of whitelist characters, ordered by descending frequency
    #   frequency : Array of frequencies of characters with the corresponding index,
    #               e.g. if character[5] = 'S', then the frequency of 'S' is frequency[5]
    #   relativeFrequency : Same format as frequency[], but instead containing relative frequencies

    charFreqRes <- charFreq(table)
    charRelFreqRes <- charRelFreq(table)
    resultFrame <- data.frame(
        character = names(charFreqRes),
        frequency = as.vector(charFreqRes),
        relativeFrequency = as.vector(charRelFreqRes)      
    )
}

proportions <- function(table) {

    # Constructs empty datafram to hold proportions of each type for every password string.
    # Iterates through the pulled string vector, calls passProportions on each given string,
    # and puts those proportions in their respective string_frame row.

    length <- NROW(table)
    string_frame <- data.frame(
        lower_case = rep(NA, length),
        upper_case = rep(NA, length),
        numerals = rep(NA, length),
        specials = rep(NA, length)
    )

    seen_table <- table[seen_count > 0,]

    i <- 0
    for (pass_string in seen_table$plaintext) {
        i <- i + 1
        string_frame[i, ] <- passProportions(pass_string)
    }

    result <- list(
        lowerCase = list(mean = mean(string_frame$lower_case), std = sd(string_frame$lower_case)),
        upperCase = list(mean = mean(string_frame$upper_case), std = sd(string_frame$upper_case)),
        numerals = list(mean = mean(string_frame$numerals), std = sd(string_frame$numerals)),
        specials = list(mean = mean(string_frame$specials), std = sd(string_frame$specials))
    )
    
}

passProportions <- function(pass) {

    # Helper functions for proportion-based stats methods.
    # Takes passed 'pass' string, converts it to a vector of ascii value equivalents,
    # and finds desired proportions accordingly

    ascii_vec <- utf8ToInt(pass)
    lower <- 0
    upper <- 0
    num <- 0
    spec <- 0
    str_length <- length(ascii_vec)

    for (pass_num in ascii_vec) {
        if (pass_num < 123 && pass_num > 96) { # Lowercase Alphabe
            lower <- lower + 1
        } else if (pass_num < 91 && pass_num > 64) { # Uppercase Alphabet
            upper <- upper + 1
        } else if (pass_num < 58 && pass_num > 47) { # Numerals`
            num <- num + 1
        } else { # Remaining Specials
            spec <- spec + 1
        } 
    }
    result <- c( lower / str_length, upper / str_length, num / str_length, spec / str_length)
}

server();
